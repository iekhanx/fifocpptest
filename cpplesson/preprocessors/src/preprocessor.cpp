/*
 * 24/03/2014    @ik
 *
 *
 * 	                  Preprocessor directives
 * 	                  =======================
 *
 * Preprocessor directives are lines included in the code of program by a hash
 * sign #. These lines are not program statement but directives for the 
 * preprocessor. The preprocessor examines the code before actual compilation
 * of code begins and resolves all these directives before any code is actually
 * generated by regualr statements.
 *
 * These preprocessor directives extend only across a single line of code. As
 * soon as a newline character is found, the preprocessor directive is ends
 * No semicolon(;) is expected at the end of a preprocessor directives. The 
 * only way a preprocessor directive can extend through more than one line is
 * by preceding the new line character at the end of the line by backslash (\).
 *
 * Macro definition (#define, #undef)
 * ==================================
 *
 * To define preprocessor macro we can use #define it syntax as follow:
 *
 *          #define  identifier replacement
 *
 * When the preprocesor encounters this directives, if replaces any occurrence
 * of identifier in the rest of the code by replacement. This replacement can
 * be an expression, a statement, a block or simply anything. The preprocessor
 * does not understand C++ proper it simply replaces any occurrence of 
 * an identifier by replacement.
 *
 *    #define TABLE_SIZE  100
 *    int table1 [TABLE_SIZE];
 *    int table2 [TABLE_SIZE];
 *
 * After the preprocessor has preplaced  TABLE_SIZE  the code become equivalent
 *
 *      int table1[100];
 *      int table2[100];
 *
 * #define can work also with paramters to define function macro.
 *
 *     #define getmax(a, b) a > b ? a : b;
 *
 * This would replace any accurrence of getmax followed by two arguments by the
 * replacement expression, but also replacing each argument by its identifier,
 * exactly as you would expect if it was a function.
 */

#include <iostream>
#include "myswitch.h"
using namespace std;
#define getmax (a,b) ((a) > (b) ? (a) : (b))

#ifdef _ONE_
int main() {
	int x = 5, y;
	y =  getmax (x, 2);
	cout << "_ONE_ an Example" << endl;
	cout << "----------------" << endl;

	cout << getmax(7, x) << endl;
   return 0;
}
#endif
/*
 * Defined macros are not affected by block structure. A macro lasts until
 * it si undefined with the #undef  preprocessor directive.
 *
 *    #define TABLE_SIZE 100
 *    int table1 [TABLE_SIZE]
 *    #undef TABLE_SIZE
 *    #define TABLE_SIZE 200
 *    int table2[TABLE_SIZE]
 * 
 * This would generate same code as ...
 *
 *     int table1 [100]
 *     int table2 [200]
 *
 * Function macro definitions accepst two special oprators # and ## the 
 * preplacement sequence.
 * If the operator # is used before a parameter is use in the replacement
 * sequence, that parameters is replaced by a string literal as if it were
 * enclosed between double quotes.
 *
 *    #define str(x) #x
 *    cout << str(test);
 *
 * This would be translated into 
 *    
 *      cout << "test";
 *
 * The operator ## concatenates two arguments leaving no blank space betweenthem
 *
 *   #define glue(a,b) a ## b
 *   glue(c.out) << "test";
 *
 * This would be also translated into
 *
 *      cout << "test";
 * 
 * Because preprocessor replacement happen becore any C++ syntax macro 
 * definition can be tricky feature. But be careful code that relies heavily
 * on complicated macros become less readable since the syntax expected is on
 * many occassions different from the normal expression programmer expert C++.
 *
 *
 *
 *
 * Conditional inclusion(#ifdef, #ifndef. #if #else #endif and #elif)
 * ==================================================================
 *
 * These directives allow to include or discard part of the code of a program
 * it a certain condition is met.
 *
 * #ifdef allows a section of a program code to be compiled only if the macro 
 * that is specified as the parameter has been defined no matter which is 
 * value is  for an example:
 *
 *           #ifdef TABLE_SIZE
 *           int table[TABLE_SIZE]
 *           #endif
 *
 * In this case the line of code int table[TABLE_SIZE] is only compiled was 
 * previously defined with #define independently of its value. If it was not
 * defined that lie will be included in the program compilation.
 *
 * #ifdef serve for the exact opposite the code between  #ifndef and #endif
 * directive is only compiled if the specified identifire has not been 
 * previously define for an example.
 *
 *           #ifndef TABLE_SIZE
 *           #define TABLE_SIZE 100
 *           #endif
 *           int table[TABLE_SIZE]
 *
 * The #if #else  and #elif (i.e. else if) directives serve to specify some 
 * condition to be met in order for the portion of code they sorround to be
 * compiled. The condition that follows #if  or #elif can only evaluate 
 * constant expression including macro.
 *
 *      #if TABLE_SIZE > 200
 *      #undef TABLE_SIZE
 *      #define TABLE_SIZE 200
 *
 *      #elif TABLE_SIZE  < 50
 *      #undef TABLE_SIZE
 *      #define TABLE_SIZE  50
 *
 *      #else
 *      #undef TABLE_SIZE 
 *      #define TABLE_SIZE 100
 *      #endif
 *
 *      int table[TABLE_SIZE]
 *
 * Notice how the entire structure of #if #elif #else chained directives end 
 * with with #endif
 *
 * The behavior of #ifdef and #ifndef can also be achieved by using the 
 * special operator defined and !defined repectively in any #if or #elif
 * directive.
 *
 *        #if !defined TABLE_SIZE
 *        #define TABLE_SIZE 100
 *        #elif define ARRAY_SIZE
 *        int table [TABLE_SIZE]   
 *        #endif
 */

/* Line control(#line)
 * ===================        
 *
 * When we compile a program and some error happens during the compiling 
 * process the compiler show an error message with reference to the name of the
 * file and line number where an error occurred so it is easiere to find the 
 * code generating the error.
 *
 * #line number "filename"
 *
 * Where number is the new line number that will be assigned to the next code
 * line, The line number of successive lines will be increased one by one from
 * the this point on.
 *
 * "filename" is an optional parameter that allows to redefine  the file name
 * that will be shown for example.
 *
 *      #line 20 "assigning variable
 *      int a?;
 *
 * This code will generate an error that will be shown as an error in the 
 * assignming variable, line 20.
 */

/* 
 * Error directive (#error)
 * ========================
 *
 * This directive aborts the compilation process when it found  compilation an
 * error that can be specified as it parameter.
 *
 *      #ifdef __cplusplus
 *      #error A C++ compiler is require!
 *      #endif
 *
 * This example abort the compilation process if the macro name _cplusplus is
 * not defined this macro name is defined by default in the all C++ compilers.
 */

/*
 *  Source file inclusing (#include#
 *  ================================
 *  
 * This directive has been used assidusouly in other section of this tutorial
 * When the preprocessor find an #include directive it
 * replace it by the entire contents of the specified header or file.
 * There are two way to use #include 
 *
 *      #include <header>
 *      #include "file"
 *
 * In this first case a header is spefied hetween an angled brackets <> 
 * This is used to include header provided by the implementeation, such as the
 * headter that compose the standard library iostream, string. Whether the 
 * headers are actually files or exist in some other form is implemented
 * as defined but in any case they shall be properly included with this dirctive
 *
 * The syntax used in the scond #include use quote and includes a file. 
 * The file is searched for in an implementation-defined manner which 
 * generally includes the current path. In the case that the file is not found 
 * the compiler interpret directive as a header inclusion just as if the
 * quotes("") were replaced by an angle brackets <>.
 */

/*
 *  Pragam directive (#pragma)
 *  ==========================
 *
 * This directive is used to specify divers option to the compiler. These 
 * options are specific for the platform and the compiler you are using.
 * Consult the manual or the reference of your compiler for more information on
 * the possible parameters that you can define with #pragma.
 *
 * If the compiler does not support a specific argument #pragma is ignore no
 * syntax error is generated.
 */

/*
 *  Predefined macro name
 *  ======================
 *
 *  The following macro name are always defined they are all begin and end
 *  with when two underscore character __)
 *
 * ============================================================================
 *     macro                                      value
 * ============================================================================
 * __LINE__    integer value representing the current line in the source code
 * __FILE__    A string literal contain the name of source file being compiled
 * __DATE__    A string literal contan mmddyy date in the compilation process
 *             began
 * __TIME__    A string literal contain hh:mm:ss contain compilation process 
 *             time began
 * _cplusplus  An integer value all C++ compiler carry this constant define to 
 *             some value. its value depends on the version of the standard
 *             supported by compiler
 *                 199711L   ISO C++ 1998/2003
 *                 201103l   ISO C++ 2011
 *             Non conforming compilers define this constant as some value at 
 *             most five digits long. Note that many compilers are not fully
 *             conforming and thus will have this consitent define as neither
 *             of the value above.
 *
 * _STD_HOSTED_ 1 = if the implementation is a hosted implementation all 
 *              standard header available 0 = otherise.
 *
 * Following macros are optionally defined generally depending on whether
 * a feature is available or not.
 *
 * ============================================================================
 *     macro                                      value
 * ============================================================================
 * _STDC_      In C if defined to 1 the implementation conform to C standard
 *             in C++ implementation defined.
 *_STDC_VERSION_     in C 
 *                   199401L   ISO C 1990 Amendment
 *		     199901L   ISO C 1999
 *		     201112l   ISO C 2011
 *                  In C++ implementation defined.
 *
 * _STDC_MB_MIGHT_NEQ_WC   1 = multibyte encoding might give a character value 
 * 			   in character literals
 * _STDC_ISO_10646         A value in the form yyyymmL specifiying the date of
 *                         an Unicode standard followed by the encoding of 
 *                         wchar_t characters.
 * _STDCPP_STRICT_POINTER_SEFTY_
 *                        1 = if the implementation has strict pointer safty
 *                        (see pointer_safty)
 * _STDCPP_THREADS__      1 = if the program can have more than one thread.
 * ---------------------------------------------------------------------------
 *
 * Particular implmentation may define additional constants.
 *
 * for an example..:
 */
#ifdef _TWO_

int main() {
	cout << "_THREE_ an Example" << endl;
	cout << "==================" << endl;

	cout << "This is the line number " << __LINE__ << endl;
	cout << "OF the file we use in   " << __FILE__ << endl;
	cout << "It compilation began on " << __TIME__ << endl;
	cout << "On the date ........... " << __DATE__ << endl;
	cout << "The compiler gives Ver. " << __cplusplus << endl;
      return 0;
}
#endif
